require(rjson)

############################################################
### Cluster colocalization results into loci
############################################################

# Description:
#
# When many nearby SNPs are tested, or when multiple GWAS are run sharing
# nearby SNPs, it can be conceptually useful to cluster these SNPs into distinct loci for 
# further follow-up. This step performs such a clustering. If only one GWAS has been
# run for colocalization, and if all loci are already sufficiently far apart, then this
# step will merely assign a locus number to each individual locus, without performing any
# grouping.
#

# Required config parameters (if this step is not skipped):
#
# "output_dir": "dir4"
# Path to the directory where all output files should be placed, including
# those generated by earlier steps in this post-processing

# Optional config parameters:
#
# "skip_steps": ["assign_locus_numbers", ...]
# If "assign_locus_numbers" is not included in the "skip_steps" list
# parameter, then it will run by default. If included,
# then this step will be skipped.
#
# "assign_locus_numbers" :
# {
#	"input_results_file": "file1",		# Optional
#	"output_results_file": "file2",		# Optional	
#	"min_locus_distance": 1000000 		# Optional; default is 1000000 (1Mb)
# }
# If included, "assign_locus_numbers" is a JSON object that contains additional parameters
# that will be used for running this filtering step. It can contain any of the following parameters:
#
#	"input_results_file": Optionally, a filtered results file as output by the "post_hoc_filtering"
#	step of this pipeline. If not specified, the file will be loaded by default from
#	{output_dir}/filtered_coloc_table.txt.
#
#	"output_results_file": Optionally, where the output of this locus assignment step should be
#	written. If not specified, the default output location will be 
#	{output_dir}/filtered_coloc_table_with_loci.txt.
#
#	"min_locus_distance": The minimum distance between two lead SNPs for them to be considered separate
#	loci. In general, we recommend 1000000 (1Mb) to minimize chances of overlap between separately
#	tagged loci, 250000 (250Kb) to separate signals as much as possible with risk of some overlap,
#	or 500000, (500Kb) for a result somewhere in between. If not specified, the parameter will
#	default to 1000000.
#
# TODO: Possible future addition: allow specification of different GWAS "groups" instead of forcing
# them to be grouped in an all-or-none fashion.
#

min_locus_distance = 1000000

main = function()
{
	# Read table with colocalization results
	
	# Load config file
	config_file = commandArgs(trailingOnly=TRUE)[1]
	config = validate_config(config_file)

	# Load results file
	results = load_results_file(config)

	# Get loci
	if (("assign_locus_numbers" %in% names(config)) && ("min_locus_distance" %in% names(config$assign_locus_numbers)))
	{
		min_locus_distance = config$assign_locus_numbers$min_locus_distance
	}
	results$locus = group_to_loci(results$ref_snp, min_locus_distance)

	# Output SNP table with loci
	if (("assign_locus_numbers" %in% names(config)) && ("output_results_file" %in% names(config$assign_locus_numbers)))
	{
		write.table(results, config$assign_locus_numbers$output_results_file, quote=FALSE, sep="\t", col.names=TRUE, row.names=FALSE)
	} else
	{
		write.table(results, file=paste(config$out_dir, "filtered_coloc_table_with_loci.txt", sep="/"), quote=FALSE, sep="\t", col.names=TRUE, row.names=FALSE)
	}
}

# Function inputs a vector of SNPs and clusters them into locis
# by distance
group_to_loci = function(x, min_dist)
{
        ids = unique(as.character(x))
	ids = ids[order(ids)]
        chr = sapply(as.character(ids), function(x) {strsplit(x, "_")[[1]][1]})
        pos = as.numeric(sapply(as.character(ids), function(x) {strsplit(x, "_")[[1]][2]}))
        loc_nums = rep(0, length(ids))
        loc_nums[1] = 1
        for (i in 2:length(ids))
        {
                # Check if there's a SNP above in the list within 1 MB of this SNP]
                same = (chr[1:(i-1)] == chr[i]) & (abs(pos[1:(i-1)] - pos[i]) < min_dist)
                if (length(which(same)) != 0)
                {
                        loc_nums[i] = loc_nums[which(same)[1]]
                }
                else
                {
                        loc_nums[i] = max(loc_nums) + 1
                }
        }

	mapped_loci = sapply(x, function(j) 
	{
			loc_nums[which(ids == j)]
        })

	return(mapped_loci)
}

load_results_file = function(config)
{
	if ((("assign_locus_numbers") %in% names(config)) && ("input_results_file" %in% names(config$assign_locus_numbers)))
	{
		d = read.table(file=config$assign_locus_numbers$input_results_file, header=TRUE)
	}
	else
	{
		d = read.table(file=paste(config$output_dir, "filtered_coloc_table.txt", sep="/"), header=TRUE)
	}

	# Quick input check
	if (!("ref_snp" %in% colnames(d)))
	{
		stop("input error: the input coloc results table must have a 'ref_snp' column")
	}

	return(d)
}

validate_config = function(config_file)
{
	# load config file, specified as a command line parameter
	config = fromjson(file=config_file)

	# validate config file to be sure required parameters are present
	if (!("output_dir" %in% names(config)))
	{
		stop("config error: you must specify 'output_dir' in config file")
	}

	return(config)
}

main()


