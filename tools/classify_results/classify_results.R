require(rjson)
require(dplyr)

############################################################
### Filter colocalization results
############################################################

# Required config parameters (if this step is not skipped):
#
# "output_dir": "dir4"
# Path to the directory where all output files should be placed, including
# those generated by earlier steps in this post-processing
#
# "skip_steps": ["classify_results", ...]
# If "classify_results" is not included in the "skip_steps" list
# parameter, then it will run by default. If included,
# then this step will be skipped.
#
# "classify_results" :
# {
# 	"full_results_file": "results_file",			# Optional
# 	"out_results_file_basename": "out_results_file",	# Optional
#
#	"rules":
#	{
#		"rule1": {...},
#		"rule2": {...},
#		...
#	}
# }
# "classify_results" is a JSON object that contains additional parameters
# that will be used for running this filtering step.
#
# 	"full_results_file" is, optionally, the file location of the colocalization results
# 	that will be processes by this script. If not included, the results will be loaded
#	from the default location, namely {TODO:}
#
#	"out_results_file_basename" is, optionally, a directory and/or prefix name that will 
#	be added to the outputs from this script. Since this script generates multiple files,
#	namely, TODO: , the default file is namely TODO:
#
#	"rules" is the bread-and-butter of the classify_results module; this object specifies
#	the rules for sorting loci into different categories. We have included some example
#	config files with rule specifications; additionally, we include a detailed documentation
#	of how to specify these rules in the "classify_results" tool-specific description.
#	We encourage you to take a look at this documentation to understand how to specify your
#	own sets of rules.
#

main = function()
{
	# Load config file
	# Validate rules too...
		# Each rule should have its own clpp threshold

	# Load results file

	# Create table for storing summary info?
	step2_list = rep("", length(loci_list))
	step3_list = rep("", length(loci_list))

	rule_list = config$classify_results$rules
	# Apply rules, one at a time
	for (rule in rule_list)
	{
		# Add column tagging loci based on this rule...
		if (rule_list$rule$type == "num_colocs")
		{
			results = class_by_num_coloc(results, rule_list$rule, rule)
		}
		else if (rule$type == "subsets")
		{
			results = class_by_study_subsets(results, rule_list$rule, rule)

		} else if (rule$type == "tiers")
		{
			results = class_by_study_tiers(results, rule_list$rule, rule)
		}
	}

	# Compute any necessary summary information

	# Output results files

}

# Perform a sort based on the number of candidate genes
# and the total number of colocalized genes
class_by_num_coloc = function(results, rule, rule_name)
{
	loci_list = unique(results$locus)
	class_membership = rep("", length(loci_list))

	# For each feature, test whether it passed colocalization threshold at this locus 
	summary = results %>% group_by(locus, qtl_feature) %>% summarize(colocs=sum(coloc_score >= rule$coloc_threshold))

	# Now summarize the number of colocalized genes and the number of candidate genes at each locus
	coloc_counts = summary %>% group_by(locus) %>% summarize(num_coloc_genes = sum(colocs > 0), num_candidate_genes=length(qtl_feature))

	# Each of these rule types takes as input a value X, a list of indices of candidate loci, and the
	# metadata about the number of colocalizations and tested genes at every locus.
	# It outputs the subset of these indices for which the corresponding loci pass the test.
	num_candidates_equals = function(x, loci, coloc_matrix)
	{
		return(loci[loci %in% (coloc_matrix[coloc_counts$num_candidate_genes == x,]$locus)])
	}
	num_colocs_equals = function(x, loci, coloc_matrix)
	{
		return(loci[loci %in% (coloc_matrix[coloc_counts$num_coloc_genes == x,]$locus)])
	}
	num_candidates_greater_than = function(x, loci, coloc_matrix)
	{
		return(loci[loci %in% (coloc_matrix[coloc_counts$num_candidate_genes > x,]$locus)])
	}
	num_colocs_greater_than = function(x, loci, coloc_matrix)
	{
		return(loci[loci %in% (coloc_matrix[coloc_counts$num_coloc_genes > x,]$locus)])
	}

	for (type in names(rule$classes))
	{
		# Keep track of all the loci passing each rule
		pass = 1:max(coloc_counts$locus)

		# Now go through all the rule types for this class to see which loci pass that rule
		if ("num_candidates_equals" %in% names(rule$classes[[type]][[1]]))
		{
			pass = num_candidates_equals(rule$classes[[type]][[1]]["num_candidates_equals"], pass, coloc_counts)
		}
		if ("num_colocs_equals" %in% names(rule$classes[[type]][[1]]))
		{
			pass = num_colocs_equals(rule$classes[[type]][[1]]["num_colocs_equals"], pass, coloc_counts)
		}
		if ("num_candidates_greater_than" %in% names(rule$classes[[type]][[1]]))
		{
			pass = num_candidates_greater_than(rule$classes[[type]][[1]]["num_candidates_greater_than"], pass, coloc_counts)
		}
		if ("num_colocs_greater_than" %in% names(rule$classes[[type]][[1]]))
		{
			pass = num_colocs_greater_than(rule$classes[[type]][[1]]["num_colocs_greater_than"], pass, coloc_counts)
		}

		# Make sure no locus has been double-classified; this would be a mistake
		if (!(sum(class_membership[which(loci_list %in% pass)] != "") == 0))
		{
			print(sprintf("Class specification error with rule %d. Some loci belong to more than one class.", rule_name))	
			# TODO: Give more details about which rules have collided.
			stop()
		}
		class_membership[which(loci_list %in% pass)] = type
	}

	# All loci should belong to a group at this point; if not, the groups are misspecified
	if(!(sum(step1_list == "") == 0))
	{
		print("Warning: not all loci ")
	}
}

# Identify loci that only colocalize in a limited subset of all GWAS or eQTL studies
class_by_study_subsets = function()
{
	# TODO: Let the clusters be clusters of GWAS or eQTL

	# Figure out which tissues had strong, weak, no colocs at each locus
	tissue_coloc = sub %>% group_by(locus, eqtl_file) %>% summarize(has_strong_coloc = as.numeric(sum(clpp_mod > strong_clpp_threshold) > 0), has_weak_only = as.numeric((sum(clpp_mod > strong_clpp_threshold) == 0) & (sum(clpp_mod > weak_clpp_threshold) > 0)), has_no_coloc = as.numeric(sum(clpp_mod > weak_clpp_threshold) == 0))

	# Make sure all groups have been assigned to exactly one of these classes
	stopifnot(sum(rowSums(tissue_coloc[,3:5]) == 0) == 0)

	strong = tissue_coloc[tissue_coloc$has_strong_coloc == 1,] 
	strong_loci = unique(strong$locus)
	strong_classes = sapply(strong_loci, function(x)
	       {
			tissues = strong[strong$locus == x,]$eqtl_file
			# Test whether the colocalized tissues match some
			# tissue group of interest
			
			for (type in names(class_config$step2_tissue_sorting))
			{
				if(sum(!(class_config$step2_tissue_sorting[[type]] %in% tissues)) + sum(!(tissues %in% class_config$step2_tissue_sorting[[type]])) == 0)
				{
					return(type)
				}
			}

			# If not, it still does have at least one coloc,
			# so doesn't belong in the "None" category
			return("Other")
	       })
	step2_list[which(loci_list %in% strong_loci)] = strong_classes

	# Then check weak colocs
	weak = tissue_coloc[tissue_coloc$has_weak_only == 1,]
	weak_loci = unique(weak$locus)
	# We only care about weak colocs if there aren't strong colocs
	weak_loci = weak_loci[!(weak_loci %in% strong_loci)]
	weak_classes = sapply(weak_loci, function(x)
	       {
			tissues = weak[weak$locus == x,]$eqtl_file
			# Test whether the colocalized tissues match some
			# tissue group of interest
			
			for (type in names(class_config$step2_tissue_sorting))
			{
				if(sum(!(class_config$step2_tissue_sorting[[type]] %in% tissues)) + sum(!(tissues %in% class_config$step2_tissue_sorting[[type]])) == 0)
				{
					return(type)
				}
			}

			# If not, it still does have at least one coloc,
			# so doesn't belong in the "None" category
			return("Other")
	       })
	step2_list[which(loci_list %in% weak_loci)] = weak_classes

	# Finally, the rest should have no colocs at all
	# Make sure these loci actually have no colocs, then tag them
	coloc_by_locus = tissue_coloc %>% group_by(locus) %>% summarize(total_coloc = sum(has_strong_coloc + has_weak_only) == 0)
	stopifnot(sum(!(step2_list[which(loci_list %in% coloc_by_locus$locus[coloc_by_locus$total_coloc])] == "")) == 0)
	step2_list[which(loci_list %in% coloc_by_locus$locus[coloc_by_locus$total_coloc])] = "None"

	# Just make sure every site's been assigned now
	stopifnot(sum(step2_list == "") == 0)
}

# Classify sites by which of a ranked list of tiers they colocalize in
class_by_study_tiers = function()
{

	###################################
	# Part 3: Which GWAS matter most?
	###################################

	top_colocs = sub %>% group_by(locus, base_gwas_file) %>% summarize(best = max(clpp_mod))

	# Tag colocalized loci by priority level
	gwas_cumul_loci = c()
	for (i in 1:length(class_config$step3_gwas_sorting))
	{
		gwas_loci = unique(top_colocs[(top_colocs$base_gwas_file %in% class_config$step3_gwas_sorting[[i]][["traits"]]) & (top_colocs$best > weak_clpp_threshold),]$locus)
		gwas_loci = gwas_loci[!(gwas_loci %in% gwas_cumul_loci)]
		step3_list[which(loci_list %in% gwas_loci)] = class_config$step3_gwas_sorting[[i]][["name"]]

		gwas_cumul_loci = c(gwas_cumul_loci, gwas_loci)
	}

	# The remainder of colocalizing loci will be tagged as "other".
	# This only matters if we have traits that are in none of the tiers.
	loci_other = top_colocs[top_colocs$best > weak_clpp_threshold,]$locus
	loci_other = loci_other[!(loci_other %in% gwas_cumul_loci)]
	step3_list[which(loci_list %in% loci_other)] = "Other"

	# Make sure all the remaining loci don't actually have any colocalization whatsoever
	# (as computed for step 2 of prioritization)
	stopifnot(sum(!(step3_list[which(loci_list %in% coloc_by_locus$locus[coloc_by_locus$total_coloc])] == "")) == 0)
	step3_list[which(loci_list %in% coloc_by_locus$locus[coloc_by_locus$total_coloc])] = "None"
	# Now just make sure all have been tagged
	stopifnot(sum(step3_list == "") == 0)


	####### Put all the results together ########

	classes = data.frame(list(locus=loci_list, step1=step1_list, step2=step2_list, step3=step3_list))
	write.table(classes, file=paste0(full_config$out_dir, "/coloc_classification_", full_config$analysis_date, ".txt"), quote=FALSE, row.names=FALSE, col.names=TRUE, sep="\t")


	results_summaries = list()
	results_summaries$step1 = classes %>% group_by(step1) %>% summarize(length(locus))
	results_summaries$step2 = classes %>% group_by(step2) %>% summarize(length(locus))
	results_summaries$step3 = classes %>% group_by(step3) %>% summarize(length(locus))


	summary_file = paste0(full_config$out_dir, "/coloc_class_summary_", full_config$analysis_date, ".txt")

	# Remove this file if it already exists
	suppressWarnings(file.remove(file=summary_file))
	suppressWarnings(lapply(results_summaries, function(x) {write.table( data.frame(x), summary_file, append= T, sep='\t', quote=FALSE, row.names=FALSE, col.names=TRUE); write("\n\n",file=summary_file, append=TRUE)}))

	# Add classifications to the original data frame and rewrite it to a file.

	data_extended = full_join(data, classes)
	write.table(data_extended, file=paste0(full_config$out_dir, "/clpp_results_categorized_", full_config$analysis_date, ".txt"), sep='\t', quote=FALSE, row.names=FALSE, col.names=TRUE)
}

main()

