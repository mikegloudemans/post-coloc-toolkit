suppressWarnings(suppressMessages(require(rjson)))

############################################################
### Cluster colocalization results into loci
############################################################

# Description:
#
# When many nearby SNPs are tested, or when multiple GWAS are run sharing
# nearby SNPs, it can be conceptually useful to cluster these SNPs into distinct loci for 
# further follow-up. This step performs such a clustering. If only one GWAS has been
# run for colocalization, and if all loci are already sufficiently far apart, then this
# step will merely assign a locus number to each individual locus, without performing any
# grouping.
#

# Required config parameters (if this step is not skipped):
#
# "output_dir": "dir4"
# Path to the directory where all output files should be placed, including
# those generated by earlier steps in this post-processing

# Optional config parameters:
#
# "skip_steps": ["assign_locus_numbers", ...]
# If "assign_locus_numbers" is not included in the "skip_steps" list
# parameter, then it will run by default. If included,
# then this step will be skipped.
#
# "assign_locus_numbers" :
# {
#	"input_results_file": "file1",		# Optional
#	"output_results_file": "file2",		# Optional	
#	"min_locus_distance": 1000000 		# Optional; default is 1000000 (1Mb)
# }
# If included, "assign_locus_numbers" is a JSON object that contains additional parameters
# that will be used for running this filtering step. It can contain any of the following parameters:
#
#	"input_results_file": Optionally, a filtered results file as output by the "post_hoc_filtering"
#	step of this pipeline. If not specified, the file will be loaded by default from
#	{output_dir}/filtered_coloc_table.txt.
#
#	"output_results_file": Optionally, where the output of this locus assignment step should be
#	written. If not specified, the default output location will be 
#	{output_dir}/filtered_coloc_table_with_loci.txt.
#
#	"min_locus_distance": The minimum distance between two lead SNPs for them to be considered separate
#	loci. In general, we recommend 1000000 (1Mb) to minimize chances of overlap between separately
#	tagged loci, 250000 (250Kb) to separate signals as much as possible with risk of some overlap,
#	or 500000, (500Kb) for a result somewhere in between. If not specified, the parameter will
#	default to 1000000.
#
# TODO: Possible future addition: allow specification of different GWAS "groups" instead of forcing
# them to be grouped in an all-or-none fashion.
#

default_distance_between_loci = 1000000

assign_locus_numbers = function(config_file, input_file, output_file)
{
	config = fromJSON(file=config_file)$assign_locus_numbers
	config$input_file = input_file
	config$output_file = output_file

	# Load results table
	results = load_results_file(config)
	
	if (FALSE)
	{		
		# Get loci
		if ("min_locus_distance" %in% names(config$assign_locus_numbers))
		{
		}
		results$locus = group_to_loci(results$ref_snp, min_locus_distance)
	}

	min_locus_distance = default_distance_between_loci

	results$locus = group_to_loci(results$ref_snp, config$genome_file)

	# Output SNP table with loci
	write.table(results, config$output_file, quote=FALSE, sep="\t", col.names=TRUE, row.names=FALSE)

	
}

# Function inputs a vector of SNPs and clusters them into locis
# by distance

group_to_loci = function(x, genome_build)
{
	# Get the set of unique reference SNPs
	ids = unique(as.character(x))
	ids = ids[order(ids)]
        chr = as.numeric(sapply(as.character(ids), function(x) {strsplit(x, "_")[[1]][1]}))
        pos = as.numeric(sapply(as.character(ids), function(x) {strsplit(x, "_")[[1]][2]}))
        loc_nums = rep(0, length(ids))

	# I ran liftOver to convert to hg38
	# liftOver fourier_ls-all.hg19.bed /mnt/lab_data/montgomery/shared/liftOver/chains/hg19ToHg38.over.chain.gz fourier_ls-all.hg38.bed fourier_ls-all.hg38.failed.bed 

	# Load European independent LD block partitioning from LDetect

	if (genome_build == "hg19")
	{
		ldetect = read.table("data/ldetect/fourier_ls-all.hg19.connected.bed", header=FALSE)
	}

	if (genome_build == "hg38")
	{
		ldetect = read.table("data/ldetect/fourier_ls-all.hg38.connected.bed", header=FALSE)
	}

	colnames(ldetect) = c("chr", "start", "stop")
	ldetect$chr = as.numeric(gsub("chr", "", ldetect$chr))
	ldetect$locus = 1:dim(ldetect)[1]

	# Assign each SNP to its own locus segment
        for (i in 1:length(ids))
	{
		# Get the chromosome we're looking for
		sub_chr = ldetect[ldetect$chr == chr[i],]
		# Get the exact block we're looking for
		sub_locus = sub_chr[sub_chr$start <= pos[i] & sub_chr$stop > pos[i],]
		loc_nums[i] = sub_locus$locus[1]
	}

	# TODO: Deal with any NA's
	mapped_loci = sapply(x, function(j) 
	{
			loc_nums[which(ids == j)]
        })

	return(mapped_loci)
}

load_results_file = function(config)
{
	d = read.table(file=config$input_file, header=TRUE, sep="\t")

	# Quick input check
	if (!("ref_snp" %in% colnames(d)))
	{
		stop("input error: the input coloc results table must have a 'ref_snp' column")
	}

	return(d)
}

args = commandArgs(trailingOnly=TRUE)

config_file = args[1]
input_file = args[2]
output_file = args[3]
assign_locus_numbers(config_file, input_file, output_file)
